# PyNOT/response
"""
Calculate the instrumental response function
"""
__author__ = 'Jens-Kristian Krogager'
__email__ = "krogager.jk@gmail.com"
__credits__ = ["Jens-Kristian Krogager"]

from argparse import ArgumentParser
import numpy as np
from astropy.io import fits
from matplotlib.backends import backend_pdf
import matplotlib.pyplot as plt
from matplotlib import ticker
from scipy.ndimage import gaussian_filter1d, median_filter
from numpy.polynomial import Chebyshev
import os
import sys
import warnings

import alfosc
from extraction import auto_extract
from alfosc import get_alfosc_header
from scired import auto_fit_background, my_formatter, mad
from wavecal import rectify


code_dir = os.path.dirname(os.path.abspath(__file__))
v_file = os.path.join(code_dir, 'VERSION')
with open(v_file) as version_file:
    __version__ = version_file.read().strip()


def load_spectrum1d(fname):
    table = fits.getdata(fname)
    wl = table['WAVE']
    flux = table['FLUX']
    return wl, flux


def flux_calibrate():
    # --- Flux calibrate:
    # Load Extinction Table:
    wl_ext, A0 = np.loadtxt(alfosc.path + '/calib/lapalma.ext', unpack=True)
    ext = np.interp(wl, wl_ext, A0)

    # Load Sensitivity Function:
    if sensitivity:
        sens_file = sensitivity
        S = pf.getdata(sens_file)
        S_hdr = pf.getheader(sens_file)
        wl_S = S_hdr['CD1_1']*np.arange(len(S)) + S_hdr['CRVAL1']
        sens_int = np.interp(wl, wl_S, S)
        # - Check that the science frame and sensitivity were observed with the same grating:
        error_msg = 'Grisms for science frame and sensitivity function do not not match!'
        assert hdr['ALGRNM'] == S_hdr['ALGRNM'], AssertionError(error_msg)
    else:
        sens_file = alfosc.path + '/calib/%s_sens.fits' % grism
        S = pf.getdata(sens_file)
        S_hdr = pf.getheader(sens_file)
        wl_S = S_hdr['CD1_1']*np.arange(len(S)) + S_hdr['CRVAL1']
        sens_int = np.interp(wl, wl_S, S)

    airm = hdr['AIRMASS']
    t = hdr['EXPTIME']
    ext_correction = 10**(0.4*airm * ext)

    flux_calibration = ext_correction / 10**(0.4*sens_int)
    flux1D = spec1D / t / dl * flux_calibration
    err1D = err1D / t / dl * flux_calibration

    flux_calib2D = np.resize(flux_calibration, img2D.T.shape)
    flux_calib2D = flux_calib2D.T
    flux2D = img2D[::-1] / t / dl * flux_calib2D
    err2D = err2D[::-1] / t / dl * flux_calib2D



def calculate_response(raw_fname, *, arc_fname, pixtable_fname, bias_fname, flat_fname, output='',
                       output_dir='', pdf_fname='', order=8, interactive=False, dispaxis=2,
                       order_wl=4, order_bg=3, rectify_options={}):
    """
    Extract and wavelength calibrate the standard star spectrum.
    Calculate the instrumental response function and fit the median filtered data points
    with a Chebyshev polynomium of the given *order*.

    Parameters
    ==========
    raw_fname : string
        File name for the standard star frame

    arc_fname : string
        File name for the associated arc frame

    pixtable_fname : string
        Filename of pixel table for the identified lines in the arc frame

    bias_fname : string
        Master bias file name to subtract bias level.
        If nothing is given, no bias level correction is performed.

    flat_fname : string
        Normalized flat file name.
        If nothing is given, no spectral flat field correction is performed.

    output : string  [default='']
        Output filename of the response function FITS Table

    output_dir : string  [default='']
        Output directory for the response function and intermediate files.
        Filenames are autogenerated from OBJECT name and GRISM

    pdf_fname : string  [default='']
        Output filename for diagnostic plots.
        If none, autogenerate from OBJECT name

    order : integer  [default=8]
        Order of the Chebyshev polynomium to fit the sensitivity

    interactive : boolean  [default=False]
        Interactively subtract background and extract 1D spectrum
        using a graphical interface. Otherwise, automatically identify
        object, subtract background and extract object.

    dispaxis : integer  [default=2]
        Dispersion axis. 1: horizontal spectra, 2: vertical spectra (default for most ALFOSC grisms)

    order_wl : integer  [default=4]
        Polynomial order for wavelength solution as function of pixel value (from `identify`)

    rectify_options : dict()  [default={}]
        Dictionary of keyword arguments for `rectify`

    Returns
    =======
    response_output : string
        Filename of resulting response function

    output_msg : string
        Log of the function call
    """
    msg = list()
    msg.append("          - Running task: calculate response function")
    mbias = fits.getdata(bias_fname)
    msg.append("          - Loaded BIAS image: %s" % bias_fname)
    mflat = fits.getdata(flat_fname)
    mflat[mflat == 0] = 1
    msg.append("          - Loaded FLAT field image: %s" % flat_fname)

    hdr = get_alfosc_header(raw_fname)
    raw2D = fits.getdata(raw_fname)
    msg.append("          - Loaded flux standard image: %s" % raw_fname)

    # Update gain for the new CCD, wrong gain written in header from the instrument
    if hdr['CCDNAME'] == 'CCD14':
        hdr['GAIN'] = 0.16
    std = (raw2D - mbias)/mflat
    hdr['DATAMIN'] = np.nanmin(std)
    hdr['DATAMAX'] = np.nanmax(std)
    hdr['EXTNAME'] = 'DATA'

    hdr.add_comment('PyNOT version %s' % __version__)
    hdr.add_comment("BIAS subtract: %s" % bias_fname)
    hdr.add_comment("FLAT correction: %s" % flat_fname)

    # Setup the filenames:
    grism = alfosc.grism_translate[hdr['ALGRNM']]
    star = hdr['TCSTGT']
    response_output = 'sens_%s_%s.fits' % (star, grism)
    std_tmp_fname = 'std_corr2D_%s.fits' % star
    rect2d_fname = 'std_rect2D_%s.fits' % star
    bgsub2d_fname = 'std_bgsub2D_%s.fits' % star
    ext1d_output = 'std_ext1D_%s.fits' % star
    extract_pdf_fname = 'std_ext1D_diagnostics.pdf'
    if output_dir:
        response_output = os.path.join(output_dir, response_output)
        std_tmp_fname = os.path.join(output_dir, std_tmp_fname)
        rect2d_fname = os.path.join(output_dir, rect2d_fname)
        bgsub2d_fname = os.path.join(output_dir, bgsub2d_fname)
        ext1d_output = os.path.join(output_dir, ext1d_output)
        extract_pdf_fname = os.path.join(output_dir, extract_pdf_fname)
    if output:
        response_output = output

    # Save the updated, bias subtracted and flat-fielded frame
    fits.writeto(std_tmp_fname, std, header=hdr, overwrite=True)
    msg.append("          - Subtracted bias and flat field corrected input image")
    msg.append("          - Saved corrected 2D image: %s" % std_tmp_fname)


    # Rectify 2D image and wavelength calibrate:
    try:
        rectify_options['plot'] = False
        rect_msg = rectify(std_tmp_fname, arc_fname, pixtable_fname, output=rect2d_fname,
                           dispaxis=dispaxis, order_wl=order_wl, **rectify_options)
        msg.append(rect_msg)
    except:
        msg.append("Unexpected error: %r" % sys.exc_info()[0])
        output_msg = "\n".join(msg)
        raise Exception(output_msg)
    # After RECTIFY all images are oriented with the dispersion axis horizontally


    # Subtract background:
    try:
        bg_msg = auto_fit_background(rect2d_fname, bgsub2d_fname, dispaxis=1, order_bg=order_bg, plot_fname='',
                                     kappa=100, fwhm_scale=5)
        msg.append(bg_msg)
    except:
        msg.append("Unexpected error: %r" % sys.exc_info()[0])
        output_msg = "\n".join(msg)
        raise Exception(output_msg)

    # Extract 1-dimensional spectrum:
    if interactive:
        raise IOError("The interactive extraction mode isn't implemented yet")
    else:
        try:
            ext_msg = auto_extract(bgsub2d_fname, ext1d_output, dispaxis=1, N=1, pdf_fname=extract_pdf_fname,
                                   model_name='tophat', dx=10, width_scale=2, order_center=4, xmin=10, ymin=5, ymax=-5)
            msg.append(ext_msg)
        except:
            msg.append("Unexpected error: %r" % sys.exc_info()[0])
            output_msg = "\n".join(msg)
            raise Exception(output_msg)

    # Check if the star name is in the header:
    if star not in alfosc.standard_star_names:
        msg.append(" [ERROR]  - No reference data found for the star %s (TCS Target Name)" % hdr['TCSTGT'])
        output_msg = "\n".join(msg)
        raise ValueError(output_msg)

    # Load the 1D extraction:
    wl, ext1d = load_spectrum1d(ext1d_output)

    # Load the spectroscopic standard table:
    # The files are located in 'calib/std/'
    star_name = alfosc.standard_star_names[star]
    std_tab = np.loadtxt(alfosc.path+'/calib/std/%s.dat' % star_name.lower())
    msg.append("          - Loaded reference data for object: %s" % star_name)

    # Calculate the flux in the pass bands:
    msg.append("          - Calculating flux in reference band passes")
    wl0 = list()
    flux0 = list()
    mag = list()
    for l0, m0, b in std_tab:
        l1 = l0 - b/2.
        l2 = l0 + b/2.
        band = (wl >= l1) * (wl <= l2)
        f0 = np.sum(ext1d[band])
        if not np.isnan(f0) and f0 > 0.:
            flux0.append(f0/b)
            wl0.append(l0)
            mag.append(m0)
    wl0 = np.array(wl0)
    flux0 = np.array(flux0)
    mag = np.array(mag)

    # Median filter the points:
    msg.append("          - Median filter and smooth the data points to remove outliers")
    med_flux_tab = median_filter(flux0, 5)
    med_flux_tab = gaussian_filter1d(med_flux_tab, 1)
    noise = mad(flux0 - med_flux_tab)*1.5
    good = np.abs(flux0 - med_flux_tab) < 2*noise
    good[:3] = True
    good[-3:] = True

    # Load extinction table:
    msg.append("          - Loaded the average extinction data for La Palma")
    wl_ext, A0 = np.loadtxt(alfosc.path + '/calib/lapalma.ext', unpack=True)
    ext = np.interp(wl0, wl_ext, A0)
    exptime = hdr['EXPTIME']
    airmass = hdr['AIRMASS']
    msg.append("          - AIRMASS: %.2f" % airmass)
    msg.append("          - EXPTIME: %.1f" % exptime)

    # Convert AB magnitudes to fluxes (F-lambda):
    F = 10**(-(mag+2.406)/2.5) / (wl0)**2

    # Calculate Sensitivity:
    C = 2.5*np.log10(flux0 / (exptime * F)) + airmass*ext

    # Fit a smooth polynomium to the calculated sensitivity:
    msg.append("          - Fitting the filtered response curve data points")
    response_fit = Chebyshev.fit(wl0[good], C[good], order, domain=[wl.min(), wl.max()])
    sens = response_fit(wl)


    # -- Prepare PDF figure:
    if not pdf_fname:
        pdf_fname = 'sens_diagnostic_' + hdr['OBJECT'] + '.pdf'
        pdf_fname = os.path.join(output_dir, pdf_fname)
    pdf = backend_pdf.PdfPages(pdf_fname)

    # Plot the extracted spectrum
    fig1 = plt.figure()
    ax = fig1.add_subplot(111)
    ax.plot(wl, ext1d)
    ax.set_ylim(ymin=0.)
    power = np.floor(np.log10(np.max(ext1d))) - 1
    majFormatter = ticker.FuncFormatter(lambda x, p: my_formatter(x, p, power))
    ax.get_yaxis().set_major_formatter(majFormatter)
    ax.set_ylabel(u'Counts  [$10^{{{0:d}}}$ ADU]'.format(int(power)), fontsize=14)
    ax.set_xlabel(u"Wavelength  [Å]", fontsize=14)
    ax.set_title(u"Filename: %s  ,  Star: %s" % (raw_fname, star.upper()))
    pdf.savefig(fig1)

    # Plot the sensitivity function:
    fig2 = plt.figure()
    ax2 = fig2.add_subplot(111)
    ax2.plot(wl0, C, color='RoyalBlue', marker='o', ls='')
    ax2.plot(wl0[~good], C[~good], color='r', marker='o', ls='')
    ax2.set_ylabel(u"Sensitivity  ($F_{\\lambda}$)", fontsize=14)
    ax2.set_xlabel(u"Wavelength  (Å)", fontsize=14)
    ax2.set_title(u"Sensitivity function, grism: "+hdr['ALGRNM'])
    ax2.plot(wl, sens, color='crimson', lw=1)
    pdf.savefig(fig2)
    pdf.close()
    msg.append("          - Plotting the sensitivity function diagnostics:  %s" % pdf_fname)

    # --- Prepare FITS output:
    sens_hdr = fits.Header()
    sens_hdr['AUTHOR'] = 'PyNOT version %s' % __version__
    col_wl = fits.Column(name='WAVE', array=wl, format='D')
    col_sens = fits.Column(name='SENS', array=sens, format='D')
    tab = fits.BinTableHDU.from_columns([col_wl, col_sens], header=sens_hdr)
    hdu = fits.HDUList()
    hdu.append(tab)
    hdu.writeto(response_output, overwrite=True)
    msg.append("          - Saved the response function as FITS table: %s" % response_output)
    msg.append("")
    output_msg = "\n".join(msg)
    return response_output, output_msg


# if __name__ == '__main__':
#     parser = ArgumentParser()
#     parser.add_argument("input", type=str,
#                         help="Raw flux standard frame")
#     parser.add_argument("arc", type=str,
#                         help="Raw arc lamp frame")
#     parser.add_argument("--bias", type=str, default='MASTER_BIAS.fits',
#                         help="Master bias frame")
#     parser.add_argument("--flat", type=str, default='',
#                         help="Normalized spectral flat frame")
#     parser.add_argument("-o", "--output", type=str, default='',
#                         help="Output directory")
#     parser.add_argument("--order", type=int, default=24,
#                         help="Polynomial order for fit to response function")
#     # parser.add_argument("--axis", type=int, default=1,
#     #                     help="Dispersion axis, 0: horizontal, 1: vertical")
#     parser.add_argument("-x", "--xrange", nargs=2, type=int, default=[None, None],
#                         help="Give lower and upper limit for the x-range to use")
#     parser.add_argument("-y", "--yrange", nargs=2, type=int, default=[None, None],
#                         help="Give lower and upper limit for the y-range to use")
#     # parser.add_argument("-v", "--verbose", action="store_true",
#     #                     help="Print status updates")
#     args = parser.parse_args()
#
#     # --- Generate sensitivity function:
#     calculate_response(args.input, arc_fname=args.arc, bias=args.bias, flat=args.flat, output_dir=args.output,
#                        trimx=args.xrange, trimy=args.yrange, order=args.order)
