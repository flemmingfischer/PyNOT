# -*- coding: UTF-8 -*-
"""
Script to combine bias and spectral flat frames for use in final data reduction.
"""
__author__ = 'Jens-Kristian Krogager'
__email__ = "krogager@iap.fr"
__credits__ = ["Jens-Kristian Krogager"]

from argparse import ArgumentParser
import numpy as np
from astropy.io import fits
from matplotlib.backends import backend_pdf
import matplotlib.pyplot as plt
from matplotlib import ticker
from scipy.ndimage import gaussian_filter1d, median_filter
from numpy.polynomial import Chebyshev
import os
import sys
import warnings

import PyNOT
import alfosc
from extraction import auto_extract
from alfosc import get_alfosc_header
from wavecal import rectify


code_dir = os.path.dirname(os.path.abspath(__file__))
v_file = os.path.join(code_dir, 'VERSION')
with open(v_file) as version_file:
    __version__ = version_file.read().strip()


def calculate_sensitivy(raw_fname, *, arc_fname, pixtable_fname, bias_fname, flat_fname,
                        output_dir='', pdf_fname='', order=8, interactive=False, dispaxis=2,
                        order_wl=4, rectify_options={}):
    """
    Extract and wavelength calibrate the standard star spectrum.
    Calculate the sensitivity function and fit the median filtered sensitivity
    with a Chebyshev polynomium of the given *order*.

    Parameters
    ==========
    raw_fname : string
        File name for the standard star frame

    arc_fname : string
        File name for the associated arc frame

    pixtable_fname : string
        Filename of pixel table for the identified lines in the arc frame

    bias_fname : string
        Master bias file name to subtract bias level.
        If nothing is given, no bias level correction is performed.

    flat_fname : string
        Normalized flat file name.
        If nothing is given, no spectral flat field correction is performed.

    output_dir : string  [default='']
        Output directory for the sensitivity function and intermediate files.
        Filenames are autogenerated from OBJECT name and GRISM

    pdf_fname : string  [default='']
        Output filename for diagnostic plots.
        If none, autogenerate from OBJECT name

    order : integer  [default=8]
        Order of the Chebyshev polynomium to fit the sensitivity

    interactive : boolean  [default=False]
        Interactively subtract background and extract 1D spectrum
        using a graphical interface. Otherwise, automatically identify
        object, subtract background and extract object.

    dispaxis : integer  [default=2]
        Dispersion axis. 1: horizontal spectra, 2: vertical spectra (default for most ALFOSC grisms)

    order_wl : integer  [default=4]
        Polynomial order for wavelength solution as function of pixel value (from `identify`)

    rectify_options : dict()  [default={}]
        Dictionary of keyword arguments for `rectify`

    Returns
    =======
    output : string
        Filename of resulting sensitivity function

    output_msg : string
        Log of the function call
    """
    msg = list
    msg.append("          - Running task: bias and flat field correction")
    mbias = fits.getdata(bias_fname)
    msg.append("          - Loaded BIAS image: %s" % bias_fname)
    mflat = fits.getdata(flat_fname)
    msg.append("          - Loaded FLAT field image: %s" % flat_fname)

    hdr = get_alfosc_header(raw_fname)
    raw2D = fits.getdata(raw_fname)
    msg.append("          - Loaded flux standard image: %s" % raw_fname)

    # Update gain for the new CCD, wrong gain written in header from the instrument
    if hdr['CCDNAME'] == 'CCD14':
        hdr['GAIN'] = 0.16
    std = (raw2D - mbias)/mflat
    hdr['DATAMIN'] = np.nanmin(std)
    hdr['DATAMAX'] = np.nanmax(std)

    hdr.add_comment('PyNOT version %s' % __version__)
    hdr.add_comment("BIAS subtract: %s" % bias_fname)
    hdr.add_comment("FLAT correction: %s" % flat_fname)

    # Save the updated, bias subtracted and flat-fielded frame
    grism = alfosc.grism_translate[hdr['ALGRNM']]
    star = hdr['TCSTGT']
    output_fname1D = 'sens_%s.fits' % grism
    std_tmp_fname = 'std_corr2D_%s.fits' % star
    rect2d_fname = 'std_rect2D_%s.fits' % star
    bgsub2d_fname = 'std_bgsub2D_%s.fits' % star
    ext1d_output = 'std_ext1D_%s.fits' % star
    extract_pdf_fname = 'std_ext1D_diagnostics.pdf'
    if output_dir:
        output_fname1D = os.path.join(output_dir, output_fname1D)
        std_tmp_fname = os.path.join(output_dir, std_tmp_fname)
        rect2d_fname = os.path.join(output_dir, rect2d_fname)
        bgsub2d_fname = os.path.join(output_dir, bgsub2d_fname)
        ext1d_output = os.path.join(output_dir, ext1d_output)
        extract_pdf_fname = os.path.join(output_dir, extract_pdf_fname)

    fits.writeto(std_tmp_fname, std, header=hdr, overwrite=True)
    msg.append("          - Subtracted bias and flat field corrected input image")
    msg.append("          - Saved corrected 2D image: %s" % std_tmp_fname)


    # -- Prepare PDF figure:
    if not pdf_fname:
        pdf_fname = 'sens_diagnostic_' + hdr['OBJECT'] + '.pdf'
    pdf = backend_pdf.PdfPages(pdf_fname)

    # Rectify 2D image and wavelength calibrate:
    try:
        rect_msg = rectify(std_tmp_fname, arc_fname, pixtable_fname, output=rect2d_fname, plot=False,
                           dispaxis=dispaxis, order_wl=order_wl, **rectify_options)
        msg.append(rect_msg)
    except:
        msg.append("Unexpected error:", sys.exc_info()[0])
        output_msg = "\n".join(msg)
        raise Exception(output_msg)


    # Subtract background:
    

    # Extract 1-dimensional spectrum:
    if interactive:
        # Load Extract GUI
        # input: bgsub2d_fname
        pass
    else:
        try:
            ext_msg = auto_extract(bgsub2d_fname, ext1d_output, dispaxis=1, N=1, pdf_fname=extract_pdf_fname,
                                   model_name='tophat', dx=10, width_scale=2, center_order=3)
            msg.append(ext_msg)
        except:
            print("Unexpected error:", sys.exc_info()[0])
            raise

    # Check if the star name is in the header:
    if hdr['TCSTGT'] in alfosc.standard_stars:
        star = hdr['TCSTGT']
    else:
        print("")
        print("  No valid star name found in the header!  TCS Target Name =  %s" % hdr['TCSTGT'])
        print("  Check if the star is listed in the directory 'calib/std'.")
        print("")


    # Plot the extracted spectrum
    fig1 = plt.figure()
    ax = fig1.add_subplot(111)
    ax.plot(wl, ext1d)
    ax.set_ylim(ymin=0.)
    power = np.floor(np.log10(np.max(ext1d))) - 1
    majFormatter = ticker.FuncFormatter(lambda x, p: PyNOT.my_formatter(x, p, power))
    ax.get_yaxis().set_major_formatter(majFormatter)
    ax.set_ylabel(u'Counts  [$10^{{{0:d}}}$ ADU]'.format(int(power)), fontsize=16)
    ax.set_xlabel(u"Wavelength  [Å]", fontsize=16)
    ax.set_title(u"Filename: %s  ,  Star: %s" % (raw_fname, star.upper()))
    pdf.savefig(fig1)

    # Load the spectroscopic standard table:
    # The files are located in 'calib/std/'
    std_tab = np.loadtxt(alfosc.path+'/calib/std/%s.dat' % star.lower())

    # Calculate the flux in the pass bands:
    wl0 = list()
    flux0 = list()
    mag = list()
    for l0, m0, b in std_tab:
        l1 = l0 - b/2.
        l2 = l0 + b/2.
        band = (wl >= l1) * (wl <= l2)
        f0 = np.sum(ext1d[band])
        if not np.isnan(f0) and f0 > 0.:
            flux0.append(f0/b)
            wl0.append(l0)
            mag.append(m0)
    wl0 = np.array(wl0)
    flux0 = np.array(flux0)
    mag = np.array(mag)

    # Median filter the points:
    med_flux_tab = median_filter(flux0, 3)
    med_flux_tab = gaussian_filter1d(med_flux_tab, 1)
    noise = PyNOT.mad(flux0 - med_flux_tab)*1.5
    good = np.abs(flux0 - med_flux_tab) < 4*noise

    # Load extinction table:
    wl_ext, A0 = np.loadtxt(alfosc.path + '/calib/lapalma.ext', unpack=True)
    ext = np.interp(wl0, wl_ext, A0)
    exptime = hdr['EXPTIME']
    airmass = hdr['AIRMASS']

    # Convert AB magnitudes to fluxes (F-lambda):
    F = 10**(-(mag+2.406)/2.5) / (wl0)**2

    # Calculate Sensitivity:
    C = 2.5*np.log10(flux0 / (exptime * F)) + airmass*ext

    # Fit a smooth polynomium to the calculated sensitivity:
    S = Chebyshev.fit(wl0[good], C[good], order)
    sens = S(wl)

    # Plot the sensitivity function:
    fig2 = plt.figure()
    ax2 = fig2.add_subplot(111)
    ax2.plot(wl0, C, color='RoyalBlue', marker='o', ls='')
    ax2.plot(wl0[~good], C[~good], color='r', marker='o', ls='')
    ax2.set_ylabel(u"Sensitivity  ($F_{\\lambda}$)", fontsize=16)
    ax2.set_xlabel(u"Wavelength  (Å)", fontsize=16)
    ax2.set_title(u"Sensitivity function, grism: "+hdr['ALGRNM'])
    ax2.plot(wl, sens, color='crimson', lw=1)
    pdf.savefig(fig2)
    pdf.close()
    print("  Details from extraction are saved to file:  %s" % pdf_filename)

    # --- Prepare output HDULists:
    dl = np.diff(wl)[0]
    hdr['CD1_1'] = dl
    hdr['CDELT1'] = dl
    hdr['CRVAL1'] = wl.min()
    ext0 = fits.PrimaryHDU(sens, header=hdr)
    HDU1D = fits.HDUList([ext0])

    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        HDU1D.writeto(output_fname1D, clobber=True)
    print("\n  Saved 1D extracted spectrum to file:  %s" % output_fname1D)
    print("")

    return wl, sens


if __name__ == '__main__':
    parser = ArgumentParser()
    parser.add_argument("input", type=str,
                        help="Raw flux standard frame")
    parser.add_argument("arc", type=str,
                        help="Raw arc lamp frame")
    parser.add_argument("--bias", type=str, default='MASTER_BIAS.fits',
                        help="Master bias frame")
    parser.add_argument("--flat", type=str, default='',
                        help="Normalized spectral flat frame")
    parser.add_argument("-o", "--output", type=str, default='',
                        help="Output filename, autogenerated by default")
    parser.add_argument("--order", type=int, default=24,
                        help="Polynomial order for fit to response function")
    # parser.add_argument("--axis", type=int, default=1,
    #                     help="Dispersion axis, 0: horizontal, 1: vertical")
    parser.add_argument("-x", "--xrange", nargs=2, type=int, default=[None, None],
                        help="Give lower and upper limit for the x-range to use")
    parser.add_argument("-y", "--yrange", nargs=2, type=int, default=[None, None],
                        help="Give lower and upper limit for the y-range to use")
    # parser.add_argument("-v", "--verbose", action="store_true",
    #                     help="Print status updates")
    args = parser.parse_args()

    # --- Generate sensitivity function:
    sensitivity(args.input, args.arc, output=args.output, bias=args.bias, flat=args.flat,
                trimx=args.xrange, trimy=args.yrange, order=args.order)
